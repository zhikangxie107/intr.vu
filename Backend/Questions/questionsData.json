[
  {
    "Two Sum": {
      "meta": {
        "id": "two-sum",
        "slug": "two-sum",
        "tag": "Arrays",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 4210,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Two Sum",
        "description": [
          "Given an array of integers nums and an integer target, return indices i and j (i < j) such that nums[i] + nums[j] == target.",
          "Assume exactly one valid answer exists; you may not use the same element twice.",
          "Return the indices in any order."
        ],
        "examples": [
          { "input": "nums = [2,7,11,15], target = 9", "output": "[0,1]", "explanation": "Because nums[0] + nums[1] == 9" },
          { "input": "nums = [3,2,4], target = 6", "output": "[1,2]" },
          { "input": "nums = [3,3], target = 6", "output": "[0,1]" }
        ],
        "constraints": [
          "2 <= nums.length <= 10^4",
          "-10^9 <= nums[i] <= 10^9",
          "-10^9 <= target <= 10^9",
          "Exactly one valid answer exists"
        ],
        "signature": { "ts": "function twoSum(nums: number[], target: number): [number, number]" },
        "starterCode": { "ts": "export function twoSum(nums: number[], target: number): [number, number] {\n  // TODO: implement\n  return [0, 0];\n}" },
        "samples": [ { "in": { "nums": [2,7,11,15], "target": 9 }, "out": [0,1] } ],
        "hiddenTests": [
          { "in": { "nums": [0,4,3,0], "target": 0 }, "out": [0,3] },
          { "in": { "nums": [-3,4,3,90], "target": 0 }, "out": [0,2] },
          { "in": { "nums": [1,5,1,5], "target": 6 }, "out": [0,1] }
        ],
        "generator": { "kind": "two-sum", "count": 50, "params": { "nMin": 2, "nMax": 200, "valMin": -1000000, "valMax": 1000000 } }
      }
    }
  },
  {
    "Valid Anagram": {
      "meta": {
        "id": "valid-anagram",
        "slug": "valid-anagram",
        "tag": "Strings",
        "duration": "5–10m",
        "durationMinutes": { "min": 5, "max": 10 },
        "likes": 2890,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Valid Anagram",
        "description": [
          "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
          "An anagram uses exactly the same characters with the same frequencies."
        ],
        "examples": [
          { "input": "s = \"anagram\", t = \"nagaram\"", "output": "true" },
          { "input": "s = \"rat\", t = \"car\"", "output": "false" }
        ],
        "constraints": [
          "1 <= s.length, t.length <= 5 * 10^4",
          "s and t consist of lowercase English letters"
        ],
        "signature": { "ts": "function isAnagram(s: string, t: string): boolean" },
        "starterCode": { "ts": "export function isAnagram(s: string, t: string): boolean {\n  // TODO: implement\n  return false;\n}" },
        "samples": [ { "in": { "s": "anagram", "t": "nagaram" }, "out": true } ],
        "hiddenTests": [
          { "in": { "s": "aacc", "t": "ccac" }, "out": false },
          { "in": { "s": "abcdef", "t": "fedcba" }, "out": true },
          { "in": { "s": "", "t": "" }, "out": true }
        ],
        "generator": { "kind": "valid-anagram", "count": 40, "params": { "minLen": 1, "maxLen": 30, "alphabet": 26, "anagramRatio": 0.5 } }
      }
    }
  },
  {
    "Binary Search": {
      "meta": {
        "id": "binary-search",
        "slug": "binary-search",
        "tag": "Arrays",
        "duration": "5–10m",
        "durationMinutes": { "min": 5, "max": 10 },
        "likes": 3145,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Binary Search",
        "description": [
          "Given a sorted integer array nums and an integer target, return the index of target if it exists; otherwise return -1."
        ],
        "examples": [
          { "input": "nums = [-1,0,3,5,9,12], target = 9", "output": "4" },
          { "input": "nums = [-1,0,3,5,9,12], target = 2", "output": "-1" }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "-10^9 <= nums[i], target <= 10^9",
          "nums is non-decreasing"
        ],
        "signature": { "ts": "function search(nums: number[], target: number): number" },
        "starterCode": { "ts": "export function search(nums: number[], target: number): number {\n  // TODO: implement\n  return -1;\n}" },
        "samples": [ { "in": { "nums": [-1,0,3,5,9,12], "target": 9 }, "out": 4 } ],
        "hiddenTests": [
          { "in": { "nums": [5], "target": 5 }, "out": 0 },
          { "in": { "nums": [1,2,3,4,5], "target": 6 }, "out": -1 },
          { "in": { "nums": [1,1,1,1], "target": 1 }, "out": 0 }
        ],
        "generator": { "kind": "binary-search", "count": 50, "params": { "nMin": 1, "nMax": 200, "valMin": -1000000, "valMax": 1000000, "ensureSorted": 1, "presentRatio": 0.6 } }
      }
    }
  },
  {
    "Best Time to Buy and Sell Stock": {
      "meta": {
        "id": "best-time-to-buy-and-sell-stock",
        "slug": "best-time-to-buy-and-sell-stock",
        "tag": "Arrays",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 5011,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Best Time to Buy and Sell Stock",
        "description": [
          "You are given an array prices where prices[i] is the price of a stock on day i.",
          "Return the maximum profit achievable from a single buy then a single sell. If no profit is possible, return 0."
        ],
        "examples": [
          { "input": "prices = [7,1,5,3,6,4]", "output": "5", "explanation": "Buy at 1, sell at 6" },
          { "input": "prices = [7,6,4,3,1]", "output": "0" }
        ],
        "constraints": [
          "1 <= prices.length <= 10^5",
          "0 <= prices[i] <= 10^4"
        ],
        "signature": { "ts": "function maxProfit(prices: number[]): number" },
        "starterCode": { "ts": "export function maxProfit(prices: number[]): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "prices": [2,4,1] }, "out": 2 } ],
        "hiddenTests": [
          { "in": { "prices": [1] }, "out": 0 },
          { "in": { "prices": [3,3,5,0,0,3,1,4] }, "out": 4 }
        ],
        "generator": { "kind": "max-profit-1", "count": 40, "params": { "nMin": 1, "nMax": 200, "valMin": 0, "valMax": 10000 } }
      }
    }
  },
  {
    "Contains Duplicate": {
      "meta": {
        "id": "contains-duplicate",
        "slug": "contains-duplicate",
        "tag": "Arrays",
        "duration": "5–10m",
        "durationMinutes": { "min": 5, "max": 10 },
        "likes": 3321,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Contains Duplicate",
        "description": [
          "Given an integer array nums, return true if any value appears at least twice and return false if every element is distinct."
        ],
        "examples": [
          { "input": "nums = [1,2,3,1]", "output": "true" },
          { "input": "nums = [1,2,3,4]", "output": "false" }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "-10^9 <= nums[i] <= 10^9"
        ],
        "signature": { "ts": "function containsDuplicate(nums: number[]): boolean" },
        "starterCode": { "ts": "export function containsDuplicate(nums: number[]): boolean {\n  // TODO: implement\n  return false;\n}" },
        "samples": [ { "in": { "nums": [1,1,2] }, "out": true } ],
        "hiddenTests": [
          { "in": { "nums": [] }, "out": false },
          { "in": { "nums": [42] }, "out": false }
        ],
        "generator": { "kind": "contains-duplicate", "count": 40, "params": { "nMin": 0, "nMax": 200, "valMin": -1000, "valMax": 1000 } }
      }
    }
  },
  {
    "Product of Array Except Self": {
      "meta": {
        "id": "product-of-array-except-self",
        "slug": "product-of-array-except-self",
        "tag": "Arrays",
        "duration": "15–20m",
        "durationMinutes": { "min": 15, "max": 20 },
        "likes": 4780,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Product of Array Except Self",
        "description": [
          "Given an integer array nums, return an array answer such that answer[i] is the product of all the elements of nums except nums[i].",
          "The product should be computed without using division and in O(n) time."
        ],
        "examples": [
          { "input": "nums = [1,2,3,4]", "output": "[24,12,8,6]" },
          { "input": "nums = [-1,1,0,-3,3]", "output": "[0,0,9,0,0]" }
        ],
        "constraints": [
          "2 <= nums.length <= 10^5",
          "-30 <= nums[i] <= 30"
        ],
        "signature": { "ts": "function productExceptSelf(nums: number[]): number[]" },
        "starterCode": { "ts": "export function productExceptSelf(nums: number[]): number[] {\n  // TODO: implement\n  return [];\n}" },
        "samples": [ { "in": { "nums": [1,2,3,4] }, "out": [24,12,8,6] } ],
        "hiddenTests": [
          { "in": { "nums": [0,0] }, "out": [0,0] },
          { "in": { "nums": [2,3,0,4] }, "out": [0,0,24,0] }
        ],
        "generator": { "kind": "product-except-self", "count": 40, "params": { "nMin": 2, "nMax": 200, "valMin": -10, "valMax": 10 } }
      }
    }
  },
  {
    "Maximum Subarray": {
      "meta": {
        "id": "maximum-subarray",
        "slug": "maximum-subarray",
        "tag": "DP",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 4102,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Maximum Subarray",
        "description": [
          "Given an integer array nums, find the contiguous subarray with the largest sum and return that sum."
        ],
        "examples": [
          { "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]", "output": "6", "explanation": "Subarray [4,-1,2,1]" },
          { "input": "nums = [1]", "output": "1" }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "-10^4 <= nums[i] <= 10^4"
        ],
        "signature": { "ts": "function maxSubArray(nums: number[]): number" },
        "starterCode": { "ts": "export function maxSubArray(nums: number[]): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "nums": [5,4,-1,7,8] }, "out": 23 } ],
        "hiddenTests": [
          { "in": { "nums": [-1,-2,-3] }, "out": -1 },
          { "in": { "nums": [0,0,0] }, "out": 0 }
        ],
        "generator": { "kind": "max-subarray", "count": 40, "params": { "nMin": 1, "nMax": 200, "valMin": -20, "valMax": 20 } }
      }
    }
  },
  {
    "Find Minimum in Rotated Sorted Array": {
      "meta": {
        "id": "find-min-rotated-sorted-array",
        "slug": "find-min-rotated-sorted-array",
        "tag": "Binary Search",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 2950,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Find Minimum in Rotated Sorted Array",
        "description": [
          "Given a rotated sorted array of unique integers, return the minimum element."
        ],
        "examples": [
          { "input": "nums = [3,4,5,1,2]", "output": "1" },
          { "input": "nums = [4,5,6,7,0,1,2]", "output": "0" }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "-10^9 <= nums[i] <= 10^9",
          "All values are unique"
        ],
        "signature": { "ts": "function findMin(nums: number[]): number" },
        "starterCode": { "ts": "export function findMin(nums: number[]): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "nums": [11,13,15,17] }, "out": 11 } ],
        "hiddenTests": [
          { "in": { "nums": [2,1] }, "out": 1 },
          { "in": { "nums": [1] }, "out": 1 }
        ],
        "generator": { "kind": "find-min-rotated", "count": 40, "params": { "nMin": 1, "nMax": 200, "valMin": -100, "valMax": 100 } }
      }
    }
  },
  {
    "Search in Rotated Sorted Array": {
      "meta": {
        "id": "search-rotated-sorted-array",
        "slug": "search-rotated-sorted-array",
        "tag": "Binary Search",
        "duration": "15–20m",
        "durationMinutes": { "min": 15, "max": 20 },
        "likes": 3620,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Search in Rotated Sorted Array",
        "description": [
          "Given a rotated sorted array of unique integers and a target, return its index or -1 if not found."
        ],
        "examples": [
          { "input": "nums = [4,5,6,7,0,1,2], target = 0", "output": "4" },
          { "input": "nums = [4,5,6,7,0,1,2], target = 3", "output": "-1" }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "-10^9 <= nums[i], target <= 10^9",
          "All values are unique"
        ],
        "signature": { "ts": "function search(nums: number[], target: number): number" },
        "starterCode": { "ts": "export function search(nums: number[], target: number): number {\n  // TODO: implement\n  return -1;\n}" },
        "samples": [ { "in": { "nums": [1], "target": 0 }, "out": -1 } ],
        "hiddenTests": [
          { "in": { "nums": [1,3], "target": 3 }, "out": 1 },
          { "in": { "nums": [5,1,3], "target": 5 }, "out": 0 }
        ],
        "generator": { "kind": "search-rotated", "count": 40, "params": { "nMin": 1, "nMax": 200, "valMin": -100, "valMax": 100 } }
      }
    }
  },
  {
    "3Sum": {
      "meta": {
        "id": "three-sum",
        "slug": "three-sum",
        "tag": "Two Pointers",
        "duration": "20–30m",
        "durationMinutes": { "min": 20, "max": 30 },
        "likes": 5022,
        "difficulty": "Medium"
      },
      "data": {
        "title": "3Sum",
        "description": [
          "Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that i != j != k and their sum is 0."
        ],
        "examples": [
          { "input": "nums = [-1,0,1,2,-1,-4]", "output": "[[-1,-1,2],[-1,0,1]]" },
          { "input": "nums = []", "output": "[]" }
        ],
        "constraints": [
          "0 <= nums.length <= 3000",
          "-10^5 <= nums[i] <= 10^5"
        ],
        "signature": { "ts": "function threeSum(nums: number[]): number[][]" },
        "starterCode": { "ts": "export function threeSum(nums: number[]): number[][] {\n  // TODO: implement\n  return [];\n}" },
        "samples": [ { "in": { "nums": [0,0,0] }, "out": [[0,0,0]] } ],
        "hiddenTests": [
          { "in": { "nums": [0,0,0,0] }, "out": [[0,0,0]] },
          { "in": { "nums": [-2,0,1,1,2] }, "out": [[-2,0,2],[-2,1,1]] }
        ],
        "generator": { "kind": "three-sum", "count": 30, "params": { "nMin": 0, "nMax": 200, "valMin": -20, "valMax": 20 } }
      }
    }
  },
  {
    "Valid Parentheses": {
      "meta": {
        "id": "valid-parentheses",
        "slug": "valid-parentheses",
        "tag": "Stack",
        "duration": "5–10m",
        "durationMinutes": { "min": 5, "max": 10 },
        "likes": 3110,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Valid Parentheses",
        "description": [
          "Given a string s containing only '()[]{}', determine if the string is valid (properly closed and nested)."
        ],
        "examples": [
          { "input": "s = \"()\"", "output": "true" },
          { "input": "s = \"(]\"", "output": "false" }
        ],
        "constraints": [
          "1 <= s.length <= 10^4"
        ],
        "signature": { "ts": "function isValid(s: string): boolean" },
        "starterCode": { "ts": "export function isValid(s: string): boolean {\n  // TODO: implement\n  return false;\n}" },
        "samples": [ { "in": { "s": "()[]{}" }, "out": true } ],
        "hiddenTests": [
          { "in": { "s": "([{}])" }, "out": true },
          { "in": { "s": "[(])" }, "out": false }
        ],
        "generator": { "kind": "valid-parentheses", "count": 40, "params": { "nMin": 1, "nMax": 50 } }
      }
    }
  },
  {
    "Merge Two Sorted Lists": {
      "meta": {
        "id": "merge-two-sorted-lists",
        "slug": "merge-two-sorted-lists",
        "tag": "Linked List",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 2805,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Merge Two Sorted Lists",
        "description": [
          "Merge two sorted singly-linked lists and return the head of the merged list."
        ],
        "examples": [
          { "input": "list1 = [1,2,4], list2 = [1,3,4]", "output": "[1,1,2,3,4,4]" },
          { "input": "list1 = [], list2 = []", "output": "[]" }
        ],
        "constraints": [
          "0 <= list length <= 50",
          "-100 <= Node.val <= 100"
        ],
        "signature": { "ts": "function mergeTwoLists(list1: number[], list2: number[]): number[]" },
        "starterCode": { "ts": "export function mergeTwoLists(list1: number[], list2: number[]): number[] {\n  // TODO: implement\n  return [];\n}" },
        "samples": [ { "in": { "list1": [], "list2": [0] }, "out": [0] } ],
        "hiddenTests": [
          { "in": { "list1": [2], "list2": [1] }, "out": [1,2] },
          { "in": { "list1": [1,1,1], "list2": [1,1] }, "out": [1,1,1,1,1] }
        ],
        "generator": { "kind": "merge-sorted", "count": 30, "params": { "nMin": 0, "nMax": 50, "valMin": -10, "valMax": 10 } }
      }
    }
  },
  {
    "Reverse Linked List": {
      "meta": {
        "id": "reverse-linked-list",
        "slug": "reverse-linked-list",
        "tag": "Linked List",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 3011,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Reverse Linked List",
        "description": [
          "Reverse a singly-linked list and return the new head."
        ],
        "examples": [
          { "input": "head = [1,2,3,4,5]", "output": "[5,4,3,2,1]" },
          { "input": "head = [1,2]", "output": "[2,1]" }
        ],
        "constraints": [
          "0 <= list length <= 5000",
          "-5000 <= Node.val <= 5000"
        ],
        "signature": { "ts": "function reverseList(head: number[]): number[]" },
        "starterCode": { "ts": "export function reverseList(head: number[]): number[] {\n  // TODO: implement\n  return head;\n}" },
        "samples": [ { "in": { "head": [] }, "out": [] } ],
        "hiddenTests": [
          { "in": { "head": [1] }, "out": [1] },
          { "in": { "head": [1,2,3] }, "out": [3,2,1] }
        ],
        "generator": { "kind": "reverse-list", "count": 30, "params": { "nMin": 0, "nMax": 50, "valMin": -10, "valMax": 10 } }
      }
    }
  },
  {
    "Linked List Cycle": {
      "meta": {
        "id": "linked-list-cycle",
        "slug": "linked-list-cycle",
        "tag": "Linked List",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 2715,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Linked List Cycle",
        "description": [
          "Given the head of a linked list, determine if the list contains a cycle."
        ],
        "examples": [
          { "input": "head = [3,2,0,-4], pos = 1", "output": "true" },
          { "input": "head = [1], pos = -1", "output": "false" }
        ],
        "constraints": [
          "0 <= list length <= 10^4",
          "-10^5 <= Node.val <= 10^5"
        ],
        "signature": { "ts": "function hasCycle(head: number[], pos: number): boolean" },
        "starterCode": { "ts": "export function hasCycle(head: number[], pos: number): boolean {\n  // TODO: implement\n  return false;\n}" },
        "samples": [ { "in": { "head": [1,2], "pos": 0 }, "out": true } ],
        "hiddenTests": [
          { "in": { "head": [], "pos": -1 }, "out": false },
          { "in": { "head": [1], "pos": 0 }, "out": true }
        ],
        "generator": { "kind": "linked-list-cycle", "count": 20, "params": { "nMin": 0, "nMax": 100 } }
      }
    }
  },
  {
    "Climbing Stairs": {
      "meta": {
        "id": "climbing-stairs",
        "slug": "climbing-stairs",
        "tag": "DP",
        "duration": "5–10m",
        "durationMinutes": { "min": 5, "max": 10 },
        "likes": 2602,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Climbing Stairs",
        "description": [
          "You are climbing a staircase. Each time you can climb 1 or 2 steps. Return the number of distinct ways to reach the top."
        ],
        "examples": [
          { "input": "n = 2", "output": "2" },
          { "input": "n = 3", "output": "3" }
        ],
        "constraints": [
          "1 <= n <= 45"
        ],
        "signature": { "ts": "function climbStairs(n: number): number" },
        "starterCode": { "ts": "export function climbStairs(n: number): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "n": 5 }, "out": 8 } ],
        "hiddenTests": [
          { "in": { "n": 1 }, "out": 1 },
          { "in": { "n": 10 }, "out": 89 }
        ],
        "generator": { "kind": "climb-stairs", "count": 30, "params": { "nMin": 1, "nMax": 45 } }
      }
    }
  },
  {
    "Coin Change": {
      "meta": {
        "id": "coin-change",
        "slug": "coin-change",
        "tag": "DP",
        "duration": "20–30m",
        "durationMinutes": { "min": 20, "max": 30 },
        "likes": 3901,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Coin Change",
        "description": [
          "Given coins of different denominations and a total amount, return the fewest number of coins needed to make up that amount. If not possible, return -1."
        ],
        "examples": [
          { "input": "coins = [1,2,5], amount = 11", "output": "3" },
          { "input": "coins = [2], amount = 3", "output": "-1" }
        ],
        "constraints": [
          "1 <= coins.length <= 12",
          "1 <= coins[i] <= 2^31 - 1",
          "0 <= amount <= 10^4"
        ],
        "signature": { "ts": "function coinChange(coins: number[], amount: number): number" },
        "starterCode": { "ts": "export function coinChange(coins: number[], amount: number): number {\n  // TODO: implement\n  return -1;\n}" },
        "samples": [ { "in": { "coins": [1], "amount": 0 }, "out": 0 } ],
        "hiddenTests": [
          { "in": { "coins": [1,3,4], "amount": 6 }, "out": 2 },
          { "in": { "coins": [2], "amount": 1 }, "out": -1 }
        ],
        "generator": { "kind": "coin-change", "count": 30, "params": { "nMin": 1, "nMax": 12, "amountMin": 0, "amountMax": 1000 } }
      }
    }
  },
  {
    "Longest Substring Without Repeating Characters": {
      "meta": {
        "id": "longest-substring-without-repeating",
        "slug": "longest-substring-without-repeating",
        "tag": "Sliding Window",
        "duration": "15–25m",
        "durationMinutes": { "min": 15, "max": 25 },
        "likes": 5202,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Longest Substring Without Repeating Characters",
        "description": [
          "Given a string s, find the length of the longest substring without repeating characters."
        ],
        "examples": [
          { "input": "s = \"abcabcbb\"", "output": "3" },
          { "input": "s = \"bbbbb\"", "output": "1" }
        ],
        "constraints": [
          "0 <= s.length <= 5 * 10^4",
          "s consists of English letters, digits, symbols and spaces"
        ],
        "signature": { "ts": "function lengthOfLongestSubstring(s: string): number" },
        "starterCode": { "ts": "export function lengthOfLongestSubstring(s: string): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "s": "pwwkew" }, "out": 3 } ],
        "hiddenTests": [
          { "in": { "s": "" }, "out": 0 },
          { "in": { "s": "dvdf" }, "out": 3 }
        ],
        "generator": { "kind": "longest-substring", "count": 30, "params": { "minLen": 0, "maxLen": 100 } }
      }
    }
  },
  {
    "Longest Palindromic Substring": {
      "meta": {
        "id": "longest-palindromic-substring",
        "slug": "longest-palindromic-substring",
        "tag": "Strings",
        "duration": "20–30m",
        "durationMinutes": { "min": 20, "max": 30 },
        "likes": 4503,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Longest Palindromic Substring",
        "description": [
          "Given a string s, return the longest palindromic substring in s."
        ],
        "examples": [
          { "input": "s = \"babad\"", "output": "\"bab\"" },
          { "input": "s = \"cbbd\"", "output": "\"bb\"" }
        ],
        "constraints": [
          "1 <= s.length <= 1000"
        ],
        "signature": { "ts": "function longestPalindrome(s: string): string" },
        "starterCode": { "ts": "export function longestPalindrome(s: string): string {\n  // TODO: implement\n  return \"\";\n}" },
        "samples": [ { "in": { "s": "a" }, "out": "a" } ],
        "hiddenTests": [
          { "in": { "s": "ac" }, "out": "a" },
          { "in": { "s": "racecar" }, "out": "racecar" }
        ],
        "generator": { "kind": "longest-pal-substr", "count": 20, "params": { "minLen": 1, "maxLen": 50 } }
      }
    }
  },
  {
    "Group Anagrams": {
      "meta": {
        "id": "group-anagrams",
        "slug": "group-anagrams",
        "tag": "Hashing",
        "duration": "15–20m",
        "durationMinutes": { "min": 15, "max": 20 },
        "likes": 3921,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Group Anagrams",
        "description": [
          "Given an array of strings strs, group the anagrams together."
        ],
        "examples": [
          { "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]", "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]" },
          { "input": "strs = [\"\"]", "output": "[[\"\"]]" }
        ],
        "constraints": [
          "1 <= strs.length <= 10^4",
          "0 <= strs[i].length <= 100"
        ],
        "signature": { "ts": "function groupAnagrams(strs: string[]): string[][]" },
        "starterCode": { "ts": "export function groupAnagrams(strs: string[]): string[][] {\n  // TODO: implement\n  return [];\n}" },
        "samples": [ { "in": { "strs": [""] }, "out": [[""]] } ],
        "hiddenTests": [
          { "in": { "strs": ["a"] }, "out": [["a"]] },
          { "in": { "strs": ["ab","ba"] }, "out": [["ab","ba"]] }
        ],
        "generator": { "kind": "group-anagrams", "count": 25, "params": { "nMin": 1, "nMax": 50, "wordLenMin": 0, "wordLenMax": 8 } }
      }
    }
  },
  {
    "Top K Frequent Elements": {
      "meta": {
        "id": "top-k-frequent-elements",
        "slug": "top-k-frequent-elements",
        "tag": "Heap",
        "duration": "15–20m",
        "durationMinutes": { "min": 15, "max": 20 },
        "likes": 3333,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Top K Frequent Elements",
        "description": [
          "Given an integer array nums and an integer k, return the k most frequent elements in any order."
        ],
        "examples": [
          { "input": "nums = [1,1,1,2,2,3], k = 2", "output": "[1,2]" },
          { "input": "nums = [1], k = 1", "output": "[1]" }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "k is in the range [1, number of unique elements]"
        ],
        "signature": { "ts": "function topKFrequent(nums: number[], k: number): number[]" },
        "starterCode": { "ts": "export function topKFrequent(nums: number[], k: number): number[] {\n  // TODO: implement\n  return [];\n}" },
        "samples": [ { "in": { "nums": [1,1,2,2,3], "k": 1 }, "out": [1] } ],
        "hiddenTests": [
          { "in": { "nums": [4,4,4,4], "k": 1 }, "out": [4] },
          { "in": { "nums": [5,6,5,6,5,7], "k": 2 }, "out": [5,6] }
        ],
        "generator": { "kind": "top-k-frequent", "count": 25, "params": { "nMin": 1, "nMax": 200, "valMin": 0, "valMax": 20 } }
      }
    }
  },
  {
    "Kth Largest Element in an Array": {
      "meta": {
        "id": "kth-largest-element",
        "slug": "kth-largest-element",
        "tag": "Heap",
        "duration": "15–20m",
        "durationMinutes": { "min": 15, "max": 20 },
        "likes": 3205,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Kth Largest Element in an Array",
        "description": [
          "Given an integer array nums and an integer k, return the kth largest element in the array."
        ],
        "examples": [
          { "input": "nums = [3,2,1,5,6,4], k = 2", "output": "5" },
          { "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4", "output": "4" }
        ],
        "constraints": [
          "1 <= k <= nums.length <= 10^5",
          "-10^9 <= nums[i] <= 10^9"
        ],
        "signature": { "ts": "function findKthLargest(nums: number[], k: number): number" },
        "starterCode": { "ts": "export function findKthLargest(nums: number[], k: number): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "nums": [1], "k": 1 }, "out": 1 } ],
        "hiddenTests": [
          { "in": { "nums": [7,6,5,4,3,2,1], "k": 5 }, "out": 3 },
          { "in": { "nums": [2,1], "k": 1 }, "out": 2 }
        ],
        "generator": { "kind": "kth-largest", "count": 25, "params": { "nMin": 1, "nMax": 200, "valMin": -100, "valMax": 100 } }
      }
    }
  },
  {
    "Number of Islands": {
      "meta": {
        "id": "number-of-islands",
        "slug": "number-of-islands",
        "tag": "Graph",
        "duration": "20–25m",
        "durationMinutes": { "min": 20, "max": 25 },
        "likes": 4877,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Number of Islands",
        "description": [
          "Given an m x n grid of '1's (land) and '0's (water), count the number of islands using 4-directional connectivity."
        ],
        "examples": [
          { "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "1" },
          { "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "output": "3" }
        ],
        "constraints": [
          "1 <= m, n <= 300"
        ],
        "signature": { "ts": "function numIslands(grid: string[][]): number" },
        "starterCode": { "ts": "export function numIslands(grid: string[][]): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "grid": [["1"]] }, "out": 1 } ],
        "hiddenTests": [
          { "in": { "grid": [["0"]] }, "out": 0 },
          { "in": { "grid": [["1","0"],["0","1"]] }, "out": 2 }
        ],
        "generator": { "kind": "num-islands", "count": 20, "params": { "mMin": 1, "mMax": 20, "nMin": 1, "nMax": 20 } }
      }
    }
  },
  {
    "Flood Fill": {
      "meta": {
        "id": "flood-fill",
        "slug": "flood-fill",
        "tag": "Graph",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 2402,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Flood Fill",
        "description": [
          "An image is represented by an m x n grid of integers image.",
          "Starting from (sr, sc), change the color of the starting pixel and any pixels connected 4-directionally with the same original color to newColor."
        ],
        "examples": [
          { "input": "image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2", "output": "[[2,2,2],[2,2,0],[2,0,1]]" }
        ],
        "constraints": [
          "1 <= m, n <= 50",
          "0 <= image[i][j], newColor < 2^16"
        ],
        "signature": { "ts": "function floodFill(image: number[][], sr: number, sc: number, newColor: number): number[][]" },
        "starterCode": { "ts": "export function floodFill(image: number[][], sr: number, sc: number, newColor: number): number[][] {\n  // TODO: implement\n  return image;\n}" },
        "samples": [ { "in": { "image": [[0,0,0],[0,1,1]], "sr": 1, "sc": 1, "newColor": 1 }, "out": [[0,0,0],[0,1,1]] } ],
        "hiddenTests": [
          { "in": { "image": [[0,0,0],[0,0,0]], "sr": 0, "sc": 0, "newColor": 1 }, "out": [[1,1,1],[1,1,1]] },
          { "in": { "image": [[2]], "sr": 0, "sc": 0, "newColor": 2 }, "out": [[2]] }
        ],
        "generator": { "kind": "flood-fill", "count": 20, "params": { "mMin": 1, "mMax": 15, "nMin": 1, "nMax": 15, "colors": 3 } }
      }
    }
  },
  {
    "Course Schedule": {
      "meta": {
        "id": "course-schedule",
        "slug": "course-schedule",
        "tag": "Graph",
        "duration": "20–30m",
        "durationMinutes": { "min": 20, "max": 30 },
        "likes": 3777,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Course Schedule",
        "description": [
          "There are numCourses courses labeled 0 to numCourses-1. Prerequisites are pairs [a, b] indicating b must be taken before a.",
          "Return true if you can finish all courses (i.e., the prerequisite graph has no cycle)."
        ],
        "examples": [
          { "input": "numCourses = 2, prerequisites = [[1,0]]", "output": "true" },
          { "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]", "output": "false" }
        ],
        "constraints": [
          "1 <= numCourses <= 10^5",
          "0 <= prerequisites.length <= 10^5"
        ],
        "signature": { "ts": "function canFinish(numCourses: number, prerequisites: number[][]): boolean" },
        "starterCode": { "ts": "export function canFinish(numCourses: number, prerequisites: number[][]): boolean {\n  // TODO: implement\n  return false;\n}" },
        "samples": [ { "in": { "numCourses": 1, "prerequisites": [] }, "out": true } ],
        "hiddenTests": [
          { "in": { "numCourses": 3, "prerequisites": [[1,0],[2,1]] }, "out": true },
          { "in": { "numCourses": 3, "prerequisites": [[0,1],[1,2],[2,0]] }, "out": false }
        ],
        "generator": { "kind": "course-schedule", "count": 20, "params": { "nMin": 1, "nMax": 50, "edgeRatio": 0.5 } }
      }
    }
  },
  {
    "Implement Queue using Stacks": {
      "meta": {
        "id": "implement-queue-using-stacks",
        "slug": "implement-queue-using-stacks",
        "tag": "Stack",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 2101,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Implement Queue using Stacks",
        "description": [
          "Implement a queue using two stacks with push, pop, peek, and empty operations."
        ],
        "examples": [
          { "input": "push(1); push(2); peek(); pop(); empty();", "output": "1,1,false" }
        ],
        "constraints": [
          "Operations <= 10^4"
        ],
        "signature": { "ts": "function myQueue(ops: string[]): string" },
        "starterCode": { "ts": "export function myQueue(ops: string[]): string {\n  // TODO: implement a queue using two stacks and simulate ops\n  return \"\";\n}" },
        "samples": [ { "in": { "ops": ["push 1","push 2","peek","pop","empty"] }, "out": "1,1,false" } ],
        "hiddenTests": [
          { "in": { "ops": ["empty"] }, "out": "true" },
          { "in": { "ops": ["push 3","pop","empty"] }, "out": "3,true" }
        ],
        "generator": { "kind": "queue-using-stacks", "count": 15, "params": { "opsMin": 1, "opsMax": 20 } }
      }
    }
  },
  {
    "Min Stack": {
      "meta": {
        "id": "min-stack",
        "slug": "min-stack",
        "tag": "Stack",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 2488,
        "difficulty": "Beginner"
      },
      "data": {
        "title": "Min Stack",
        "description": [
          "Design a stack that supports push, pop, top, and retrieving the minimum element in O(1) time."
        ],
        "examples": [
          { "input": "push(-2); push(0); push(-3); getMin(); pop(); top(); getMin();", "output": "-3,0,-2" }
        ],
        "constraints": [
          "Operations <= 10^4"
        ],
        "signature": { "ts": "function minStack(ops: string[]): string" },
        "starterCode": { "ts": "export function minStack(ops: string[]): string {\n  // TODO: implement MinStack and simulate ops\n  return \"\";\n}" },
        "samples": [ { "in": { "ops": ["push -2","push 0","push -3","getMin","pop","top","getMin"] }, "out": "-3,0,-2" } ],
        "hiddenTests": [
          { "in": { "ops": ["push 1","getMin"] }, "out": "1" },
          { "in": { "ops": ["push 2","push 1","getMin","pop","getMin"] }, "out": "1,2" }
        ],
        "generator": { "kind": "min-stack", "count": 15, "params": { "opsMin": 1, "opsMax": 20 } }
      }
    }
  },
  {
    "Lowest Common Ancestor of a BST": {
      "meta": {
        "id": "lca-bst",
        "slug": "lca-bst",
        "tag": "Trees",
        "duration": "10–15m",
        "durationMinutes": { "min": 10, "max": 15 },
        "likes": 2301,
        "difficulty": "Medium"
      },
      "data": {
        "title": "Lowest Common Ancestor of a BST",
        "description": [
          "Given a Binary Search Tree (BST), find the lowest common ancestor (LCA) of two nodes p and q."
        ],
        "examples": [
          { "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8", "output": "6" },
          { "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4", "output": "2" }
        ],
        "constraints": [
          "2 <= nodes <= 10^5",
          "-10^9 <= Node.val <= 10^9"
        ],
        "signature": { "ts": "function lowestCommonAncestorBST(root: number[], p: number, q: number): number" },
        "starterCode": { "ts": "export function lowestCommonAncestorBST(root: number[], p: number, q: number): number {\n  // TODO: implement\n  return 0;\n}" },
        "samples": [ { "in": { "root": [2,1], "p": 1, "q": 2 }, "out": 2 } ],
        "hiddenTests": [
          { "in": { "root": [1,null,2], "p": 1, "q": 2 }, "out": 1 }
        ],
        "generator": { "kind": "lca-bst", "count": 15, "params": { "nMin": 2, "nMax": 50 } }
      }
    }
  }
]
